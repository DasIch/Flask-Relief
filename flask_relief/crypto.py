# coding: utf-8
"""
    flask.ext.relief.crypto
    ~~~~~~~~~~~~~~~~~~~~~~~

    :copyright: 2013 by Daniel Neuh√§user
    :license: BSD, see LICENSE.rst for details
"""
import os

from flask.ext.relief._compat import int_to_byte, PY2


def xor_bytes(a, b):
    """
    XORs each byte in `a` and `b` together and returns the concatenated result.
    """
    return b''.join(
        int_to_byte(x ^ y) for x, y in zip(bytearray(a), bytearray(b))
    )


def encrypt_once(plaintext):
    """
    Returns a random key and the ciphertext of a one-time pad, generated using
    the returned key and the given `plaintext`. Expects everything to be bytes.
    """
    key = os.urandom(len(plaintext))
    return key, xor_bytes(key, plaintext)


def decrypt_once(key, ciphertext):
    """
    Decrypts a one-time pad as generated by :func:`encrypt_once` and returns
    the plaintext.
    """
    return xor_bytes(key, ciphertext)


def constant_time_equal(a, b):
    """
    Returns `True` if the strings `a` and `b` are equal. `a` and `b` are
    compared in constant time, short circuiting if they are of different
    length.

    This function exposes the length of the strings that are compared but does
    not expose upto which position the strings are equal. This makes it
    suitable for comparisions of untrusted with secret strings, if the length
    of the secret string is public knowledge.
    """
    if len(a) != len(b):
        return False
    result = 0
    if isinstance(a, bytes) and isinstance(b, bytes) and not PY2:
        for x, y in zip(a, b):
            result |= x ^ y
    else:
        for x, y in zip(a, b):
            result |= ord(x) ^ ord(y)
    return result == 0
